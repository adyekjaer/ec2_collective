#!/usr/bin/env python
# coding: utf-8

from boto.sqs import connect_to_region
from boto.exception import SQSError
import simplejson as json
import time
import signal
import sys
import getopt
import os
import random
import string
import logging

# CFG FILE
CFILE='/etc/ec2_collective/ec2-cmaster.json'

def get_config():
    if not os.path.exists(CFILE):
        print CFILE + ' file does not exist'
        sys.exit(1)

    try:
        fp = open(CFILE, 'r')
    except IOError, e:
        print ('Failed to open ' + CFILE + ' (%d) %s \n' % (e.errno, e.strerror))
        sys.exit(1)
    
    try:
        global CFG
        CFG=json.load(fp)
    except (TypeError, ValueError), e:
        print 'Error in configuration file'
        sys.exit(1)

def set_logging(logfile=False):

    log = logging.getLogger()

    if logfile is not False:

        if os.path.exists(os.path.dirname(logfile)):
            fh = logging.FileHandler(logfile)
            log.addHandler(fh)
        else:
            print >>sys.stderr, 'Log directory does not exist (' + os.path.dirname(logfile) + ')'
            sys.exit(1)

        fh_fmt = logging.Formatter("%(asctime)s %(message)s")
        fh.setFormatter(fh_fmt)
     
    ch  = logging.StreamHandler()
    log.addHandler(ch)
     
    log.setLevel(logging.INFO)  

def usage():
    print >>sys.stderr, '    Usage:'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c <command>'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c <command> -l <path to logfile>\t output to console and logfile'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c <command> -w key=value\tAgent must match this fact'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c <command> -n key=value\tAgent must NOT match this fact'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c file://path/to/some/script\tSend file and make agent execute it'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c s3://bucket/script\tAsk agent to fetch script from s3 and execute'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c [file://|s3://] -p arg1 arg2\tSend arguments to file:// or s3:// scripts'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -m \tGet a count on responding hosts'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c <command> -i\tIgnore i.e. fire and forget mode'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -q <queue name> -c <command>\tOverwrite default SQS queue name'
    print >>sys.stderr, '    ' + sys.argv[0] + ' -c <command> -t <seconds>\tOverwrite default timeout for agent to respond'
    sys.exit(1)

def main():

    global MASTER_EC
    MASTER_EC=0

    # Get configuration
    get_config()

    # Defaults
    func='ping'
    schedule=time.time()
    cmd=None
    wf=None
    wof=None
    timeout=int(CFG['general']['default_timeout'])
    timeout_set = False
    ignore=False
    script_param=None
    logfile=False

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hs:c:w:n:t:ip:q:ml:', ['help', 'schedule=', 'command=', 'wf=', 'wc=', 'wof=', 'timeout=', 'ignore', 'script-parameters=', 'sqs-queue=', 'monitor', 'logfile='])
    except getopt.GetoptError, err:
        print >>sys.stderr, str(err) 
        return 1

    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
        elif o in ('-s', '--schedule'):
            if a != 'now':
                # We use the following ts MMDDHHMM
                schedule=a
        elif o in ('-c', '--command'):
            cmd = a
            if 'file://' in cmd:
                func='script'
                cmd = cmd[7:]
            elif 's3://' in cmd:
                func='s3'
                cmd = cmd[5:]
            else:
                func='cli'
        elif o in ('-w', '--wf', '--wc'):
            if wf is not None:
                wf = wf + ',' + a
	    else:
                wf = a
        elif o in ('-n', '--wof'):
            if wof is not None:
                wof = wof + ',' + a
	    else:
                wof = a
        elif o in ('-t', '--timeout'):
            try:
                timeout = int(a)
                timeout_set = True
            except:
                print 'Timeout value is not an integer'
                sys.exit(1)
        elif o in ('-i', '--ignore'):
            ignore = True
            if timeout_set is False:
                # We allow a 5 second response time unless something else is set
                timeout = 5
        elif o in ('-p', '--script-parameters'):
            if func in ['script', 's3']:
                script_param = a
        elif o in ('-q', '--sqs-queue'):
            CFG['aws']['write_queue'] = str(a)
        elif o in ('-m', '--monitor'):
            func='count'
        elif o in ('-l', '--logfile'):
            logfile=a

    if func is None:
        print >>sys.stderr, 'Please provide function'
        usage()

    if func not in ['ping', 'count', 'cli', 'script', 's3' ]:
        print 'Uknown function: ' + str(a)
        usage()

    set_logging(logfile)

    run (func, schedule, cmd, wf, wof, timeout, ignore, script_param)

# Signal handler
def master_timeout(signum, frame):
    logging.error('Timeout reached - exiting')
    sys.exit(1)

# When timeout happens master_timeout definition executes raising an exception
signal.signal(signal.SIGALRM, master_timeout)

def func_ping_response (responses):
    for response in responses:
        hostname = str(responses[response]['hostname'])
        output = str(responses[response]['output'])

        response_time = round( (time.time() - float(output)) * 1000, 2 )
        response_str = hostname + ' time=' + str(response_time) + ' ms'

        logging.info(response_str)

def func_cli_response (responses):

    global MASTER_EC

    for response in responses:
        hostname = str(responses[response]['hostname'])
        output = str(responses[response]['output'])
        rc = str(responses[response]['rc'])

        if int(responses[response]['rc']) != 0:
            MASTER_EC = responses[response]['rc']

        response_str = '>>>>>> ' + hostname + ' exit code: ('+str(rc)+'):\n' +  str(output)

        logging.info(response_str)

def receive_responses (read_queue, org_ids, func, timeout, display, discovered=None):

    if func in [ 'ping','discovery','count']:
        timeout=CFG['general']['ping_timeout']

    total_responses = {}
    old_msgs = {}
    agent_msgs = {}

    start_time=int(time.time())
    while ( True ):
        responses, old_msgs, agents_msgs = pull_msgs (read_queue, org_ids, func, old_msgs, agent_msgs)
        if len(responses) > 0:
            total_responses.update(responses)

            if func in [ 'ping','discovery','count'] and display == 'display':
                func_ping_response(responses)

            if func in ['cli', 'script','s3' ] and display == 'display':
                func_cli_response(responses)

        if discovered is not None and len(total_responses) >= discovered:
            break

        if ((int(time.time()) - start_time) >= timeout):
            break

    return total_responses

def pull_msgs (read_queue, org_ids, org_func, old_msgs, agent_msgs):

    response = None
    responses = {}

    # Receive at least 1 message be fore continuing 
    rmsgs = read_queue.get_messages(num_messages=10, visibility_timeout=2)

    # For each message we check for duplicate, and if it is a response to our org message
    for rmsg in rmsgs:

        # PUT FIRST Avoid duplicates 
        if rmsg.id in old_msgs:
            continue
        else:
            old_msgs[rmsg.id] = rmsg.id

        response=json.loads(rmsg.get_body())
        msg_id = str(response['msg_id'])
        func = str(response['func'])
        hostname = str(response['hostname'])

        # Is it a response to our original request
        if msg_id not in org_ids:
            # Dont handle it again
            old_msgs[rmsg.id] = rmsg.id
            continue

        if hostname in agent_msgs:
            old_msgs[rmsg.id] = rmsg.id
            if not read_queue.delete_message(rmsg):
                logging.error('Failed to delete reponse message')
            continue
        else:
            agent_msgs[hostname] = hostname

        if ( org_func != func ):
            logging.error('Type differs from original! (' + str(org_func) + ') != (' + str(func) + ')' ' - skipping')
            old_msgs[rmsg.id] = rmsg.id
            continue

        responses[hostname] = response

        # We're done with the message - delete it
        if not read_queue.delete_message(rmsg):
            logging.error('Failed to delete reponse message')

    # Retrun all responses
    return (responses, old_msgs, agent_msgs)

def delete_org_message (write_queue, msg_ids):

    signal.alarm(CFG['general']['clean_timeout'])

    while ( True ):
        msg_ids = pull_org_msgs (write_queue, msg_ids)
        if len(msg_ids) == 0:
            break

    signal.alarm(0)

def pull_org_msgs(write_queue, msg_ids):

    # Pick up written message and delete it
    wmsgs = write_queue.get_messages(num_messages=10, visibility_timeout=2)
    
    for wmsg in wmsgs:
    
        if wmsg.id in msg_ids:
            if not write_queue.delete_message(wmsg):
                logging.error('Failed to delete original command message')
                continue
            else:
                del msg_ids[wmsg.id]
        else:
            continue

    return msg_ids

def id_generator(size=10, chars=string.ascii_uppercase + string.digits):
    return ''.join(random.choice(chars) for x in range(size))

def dict_to_sqs_obj(message, write_queue):

    message_json=json.dumps(message)

    if len(message) >= 65536:
        logging.error ('Message is too big to put on SQS')
        sys.exit(1)

    try:
        message = write_queue.new_message(message_json)
    except:
        logging.error('Failed to create message object - check queue name')
        sys.exit(1)

    return message

def write_msg (write_queue, dict_message):

    message=dict_to_sqs_obj(dict_message, write_queue)
    org_ids={}

    written=False
    for i in range(0, 3):
        try:
            org = write_queue.write(message)
        except:
            logging.error('Failed to write command message')
            sys.exit(1)

        if org.id is None:
            logging.error('Failed to write 1 command message')
        else:
            written=True
            org_ids[org.id] = org.id

    if written is True:
        return org_ids
    else:
        logging.error('Failed to write any command messages')
        sys.exit(1)

def inhale_script (script_file):
    if not os.path.exists(script_file):
        logging.error(str(script_file) + ' file does not exist')
        sys.exit(1)

    f = open(script_file, 'r')

    return f.read()

def run(func, schedule, cmd, wf, wof, timeout, ignore, script_param):

    payload = None

    if func == 'script':
        payload = inhale_script(cmd)
        cmd = os.path.basename(cmd)

    responses={}
    ping_responses={}
    org_ids={}
    discovered=None

    # Connect with key, secret and region
    try:
        conn = connect_to_region(CFG['aws']['region'])
    except:
        logging.error('Could not connect to SQS - check your authentication')
        sys.exit(1)

    write_queue = conn.get_queue(CFG['aws']['write_queue'])
    read_queue = conn.get_queue(CFG['aws']['read_queue'])

    if write_queue is None or read_queue is None:
        logging.error('Unable to get queue by name')
        sys.exit(1)

    # Construct message
    message={'func':func,'schedule':schedule, 'cmd':cmd, 'ts':time.time(), 'wf':wf, 'wof':wof, 'batch_msg_id':id_generator(), 'payload':payload, 'script_param':script_param}

    # 15 second initial timeout  
    if func == 'count':
        org_ids.update (write_msg(write_queue, message))

        responses = receive_responses (read_queue, org_ids, func, timeout, 'nodisplay')
	logging.info(str(len(responses)))

    if func == 'ping' or func == 'discovery':
        org_ids.update (write_msg(write_queue, message))
        responses = receive_responses (read_queue, org_ids, func, timeout, 'display')

    if func == 'cli':

        # If ignore is True then we fire and forget
        if ignore is False:
            # Perform a ping to figure out how many replies to expect
            message['func'] = 'count'
            count_ids =  (write_msg(write_queue, message))
            org_ids.update (count_ids)
            ping_responses = receive_responses (read_queue, count_ids, 'count', timeout, 'nodisplay')
            discovered=len(ping_responses)
        else:
            discovered=None
            
        # Perform the actual command wait for all agents to return until timeout
        message['func'] = 'cli'
        message['batch_msg_id'] = id_generator()
        cli_ids =  (write_msg(write_queue, message))
        org_ids.update (cli_ids)
        responses = receive_responses (read_queue, cli_ids, func, timeout, 'display', discovered)

    if func in [ 'script', 's3' ]:

        # If ignore is True then we fire and forget
        if ignore is False:
            # Perform a ping to figure out how many replies to expect
            message['func'] = 'count'
            count_ids =  (write_msg(write_queue, message))
            org_ids.update (count_ids)
            ping_responses = receive_responses (read_queue, count_ids, 'count', timeout, 'nodisplay')
            discovered=len(ping_responses)
        else:
            discovered=None

        # Perform the actual command wait for all agents to return until timeout
        message['func'] = func
        message['batch_msg_id'] = id_generator()
        cli_ids =  (write_msg(write_queue, message))
        org_ids.update (cli_ids)
        responses = receive_responses (read_queue, cli_ids, func, timeout, 'display', discovered)

    # Delete original messags
    delete_org_message (write_queue, org_ids)

    if func in ['cli', 'script', 's3'] and ignore is False and len(ping_responses) != len(responses):
        for hostname in ping_responses.keys():
            if not hostname in responses:
                logging.warn('Timeout in response from: ' + hostname)

        # If some of the expected servers did not answer we exit 1
        sys.exit(1)

    if func is not 'count':
        logging.info('Got response from ' + str(len(responses)) + ' out of ' + str(len(ping_responses)) + ' (discovered)')

    # If we had no matches we exit non 1
    if len(responses) == 0:
        sys.exit(1)
    else:
        sys.exit(MASTER_EC)

if __name__ == "__main__":
    sys.exit(main())
